<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Simulation Circuit de Monaco - Vue 2D + Analyse 3D</title>
    
    <!-- React et ReactDOM -->
    <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    
    <!-- Plotly -->
    <script src="https://cdn.plot.ly/plotly-2.27.0.min.js"></script>
    
    <!-- Babel Standalone pour JSX -->
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Roboto', 'Oxygen', 'Ubuntu', 'Cantarell', sans-serif;
            background: linear-gradient(135deg, #0a0a0a 0%, #1a1a2e 100%);
            color: #ffffff;
            min-height: 100vh;
            overflow-x: hidden;
        }
        
        #loading-screen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(135deg, #0a0a0a 0%, #1a1a2e 100%);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 9999;
            transition: opacity 0.5s;
        }
        
        #loading-screen.hidden {
            opacity: 0;
            pointer-events: none;
        }
        
        .loader {
            width: 60px;
            height: 60px;
            border: 5px solid rgba(0, 255, 0, 0.2);
            border-top-color: #00ff00;
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }
        
        @keyframes spin {
            to { transform: rotate(360deg); }
        }
        
        .loading-text {
            margin-top: 20px;
            font-size: 18px;
            color: #00ff00;
            text-align: center;
        }
        
        .loading-details {
            margin-top: 10px;
            font-size: 14px;
            color: #888;
            max-width: 90%;
            text-align: center;
        }
        
        .resource-list {
            margin-top: 20px;
            max-width: 500px;
            width: 90%;
        }
        
        .resource-item {
            display: flex;
            align-items: center;
            padding: 8px;
            margin: 5px 0;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 5px;
            font-size: 12px;
        }
        
        .resource-status {
            width: 20px;
            height: 20px;
            border-radius: 50%;
            margin-right: 10px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 12px;
        }
        
        .resource-status.loading {
            background: #ffaa00;
        }
        
        .resource-status.loaded {
            background: #00ff00;
        }
        
        .resource-status.error {
            background: #ff0000;
        }
        
        .debug-panel {
            position: fixed;
            bottom: 10px;
            left: 10px;
            right: 10px;
            max-height: 150px;
            overflow-y: auto;
            background: rgba(0, 0, 0, 0.9);
            border: 1px solid #333;
            border-radius: 5px;
            padding: 10px;
            font-family: monospace;
            font-size: 11px;
            color: #0f0;
            display: none;
            z-index: 1000;
        }
        
        .debug-panel.show {
            display: block;
        }
        
        .debug-log {
            margin: 2px 0;
        }
        
        .debug-log.error {
            color: #ff4444;
        }
        
        .debug-log.warning {
            color: #ffaa00;
        }
        
        .debug-log.success {
            color: #00ff00;
        }
        
        .debug-toggle {
            position: fixed;
            bottom: 10px;
            right: 10px;
            padding: 10px 15px;
            background: rgba(0, 255, 0, 0.9);
            border: 1px solid #00ff00;
            border-radius: 5_px;
            color: #000;
            cursor: pointer;
            z-index: 1001;
            font-size: 12px;
            font-weight: bold;
            box-shadow: 0 2px 10px rgba(0, 255, 0, 0.5);
            transition: all 0.3s;
        }
        
        .debug-toggle:hover {
            transform: scale(1.05);
            box-shadow: 0 4px 15px rgba(0, 255, 0, 0.7);
        }
        
        .debug-toggle:active {
            transform: scale(0.95);
        }
        
        /* Optimisations mobile */
        @media (max-width: 768px) {
            .debug-toggle {
                bottom: 5px;
                right: 5px;
                padding: 8px 12px;
                font-size: 11px;
            }
            
            .debug-panel {
                bottom: 5px;
                left: 5px;
                right: 5px;
                max-height: 120px;
                font-size: 10px;
            }
            
            button {
                padding: 12px 30px;
                font-size: 16px;
                touch-action: manipulation;
            }
        }
        
        canvas {
            touch-action: none;
            -webkit-tap-highlight-color: transparent;
        }
        
        .container {
            padding: 20px;
            max-width: 1600px;
            margin: 0 auto;
        }
        
        h1 {
            text-align: center;
            font-size: 2.5em;
            margin-bottom: 10px;
            background: linear-gradient(45deg, #ff0000, #ff6600, #00ff00);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            animation: gradientShift 3s ease infinite;
        }
        
        @keyframes gradientShift {
            0%, 100% { filter: hue-rotate(0deg); }
            50% { filter: hue-rotate(20deg); }
        }
        
        .subtitle {
            text-align: center;
            color: #888;
            margin-bottom: 30px;
            font-size: 1.1em;
        }
        
        .main-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            margin-bottom: 20px;
        }
        
        @media (max-width: 1200px) {
            .main-grid {
                grid-template-columns: 1fr;
            }
        }
        
        .circuit-panel, .plot-panel {
            background: rgba(26, 26, 46, 0.6);
            border-radius: 12px;
            border: 2px solid rgba(255, 255, 255, 0.1);
            padding: 20px;
            backdrop-filter: blur(10px);
        }
        
        canvas {
            width: 100%;
            max-width: 800px;
            border: 2px solid #333;
            border-radius: 8px;
            display: block;
            margin: 0 auto;
            background: #000;
            box-shadow: 0 8px 32px rgba(0, 255, 0, 0.2);
            touch-action: none;
            -webkit-tap-highlight-color: transparent;
            image-rendering: -webkit-optimize-contrast;
            image-rendering: crisp-edges;
        }
        
        @media (max-width: 768px) {
            canvas {
                max-width: 100%;
                height: auto;
            }
        }
        
        .controls {
            text-align: center;
            margin-top: 20px;
        }
        
        button {
            padding: 14px 40px;
            font-size: 18px;
            font-weight: bold;
            border: none;
            border-radius: 30px;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 4px 20px rgba(0, 255, 0, 0.3);
            text-transform: uppercase;
            letter-spacing: 1px;
        }
        
        button.start {
            background: linear-gradient(135deg, #00ff00, #00cc00);
            color: #000;
        }
        
        button.stop {
            background: linear-gradient(135deg, #ff4444, #cc0000);
            color: #fff;
        }
        
        button:hover {
            transform: scale(1.05);
            box-shadow: 0 6px 30px rgba(0, 255, 0, 0.5);
        }
        
        button:active {
            transform: scale(0.98);
        }
        
        .legend, .info-box {
            margin-top: 20px;
            padding: 20px;
            background: rgba(0, 0, 0, 0.5);
            border-radius: 8px;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }
        
        .legend h3, .info-box h3 {
            margin-top: 0;
            margin-bottom: 15px;
            color: #00ff00;
            font-size: 1.2em;
        }
        
        .legend-items {
            display: flex;
            gap: 25px;
            flex-wrap: wrap;
        }
        
        .legend-item {
            display: flex;
            align-items: center;
            gap: 10px;
        }
        
        .legend-color {
            width: 30px;
            height: 15px;
            border: 1px solid #fff;
            border-radius: 3px;
        }
        
        #plot3d {
            width: 100%;
            height: 550px;
            border: 2px solid #333;
            border-radius: 8px;
            background: #1a1a1a;
            box-shadow: 0 8px 32px rgba(0, 100, 255, 0.2);
        }
        
        .info-box p {
            margin: 8px 0;
            line-height: 1.6;
        }
        
        .info-box strong {
            color: #00ff00;
        }
        
        .stats-note {
            color: #888;
            font-size: 0.9em;
            margin-top: 15px;
            padding-top: 15px;
            border-top: 1px solid rgba(255, 255, 255, 0.1);
        }
    </style>
</head>
<body>
    <!-- √âcran de chargement -->
    <div id="loading-screen">
        <div class="loader"></div>
        <div class="loading-text">Chargement des ressources...</div>
        <div class="loading-details">Veuillez patienter</div>
        <div class="resource-list">
            <div class="resource-item">
                <div class="resource-status loading" id="status-react">‚è≥</div>
                <span>React 18</span>
            </div>
            <div class="resource-item">
                <div class="resource-status loading" id="status-reactdom">‚è≥</div>
                <span>ReactDOM 18</span>
            </div>
            <div class="resource-item">
                <div class="resource-status loading" id="status-plotly">‚è≥</div>
                <span>Plotly.js</span>
            </div>
            <div class="resource-item">
                <div class="resource-status loading" id="status-babel">‚è≥</div>
                <span>Babel Standalone</span>
            </div>
        </div>
    </div>

    <!-- Panneau de debug -->
    <div class="debug-toggle" onclick="toggleDebug()">üìä Debug</div>
    <div class="debug-panel" id="debug-panel"></div>

    <div id="root"></div>

    <script>
        // Syst√®me de logging et debug
        const debugLogs = [];
        const maxLogs = 50;
        
        function log(message, type = 'info') {
            const timestamp = new Date().toLocaleTimeString();
            const logEntry = { timestamp, message, type };
            debugLogs.push(logEntry);
            if (debugLogs.length > maxLogs) debugLogs.shift();
            
            console.log(`[${timestamp}] ${message}`);
            updateDebugPanel();
        }
        
        function updateDebugPanel() {
            const panel = document.getElementById('debug-panel');
            if (!panel) return;
            
            panel.innerHTML = debugLogs.map(log => 
                `<div class="debug-log ${log.type}">[${log.timestamp}] ${log.message}</div>`
            ).join('');
            panel.scrollTop = panel.scrollHeight;
        }
        
        function toggleDebug() {
            const panel = document.getElementById('debug-panel');
            panel.classList.toggle('show');
        }
        
        // Gestion du chargement des ressources
        const resources = {
            react: { loaded: false, url: 'https://unpkg.com/react@18/umd/react.production.min.js' },
            reactdom: { loaded: false, url: 'https://unpkg.com/react-dom@18/umd/react-dom.production.min.js' },
            plotly: { loaded: false, url: 'https://cdn.plot.ly/plotly-2.27.0.min.js' },
            babel: { loaded: false, url: 'https://unpkg.com/@babel/standalone/babel.min.js' }
        };
        
        function updateResourceStatus(name, status) {
            const statusEl = document.getElementById(`status-${name}`);
            if (!statusEl) return;
            
            statusEl.className = `resource-status ${status}`;
            if (status === 'loaded') {
                statusEl.textContent = '‚úì';
            } else if (status === 'error') {
                statusEl.textContent = '‚úó';
            }
        }
        
        function checkAllResourcesLoaded() {
            const allLoaded = Object.values(resources).every(r => r.loaded);
            if (allLoaded) {
                log('Toutes les ressources charg√©es avec succ√®s', 'success');
                setTimeout(() => {
                    const loadingScreen = document.getElementById('loading-screen');
                    loadingScreen.classList.add('hidden');
                    setTimeout(() => loadingScreen.remove(), 500);
                    initializeApp();
                }, 500);
            }
        }
        
        function loadScript(name, url) {
            return new Promise((resolve, reject) => {
                log(`Chargement de ${name}...`, 'info');
                
                const script = document.createElement('script');
                script.src = url;
                script.async = false;
                
                script.onload = () => {
                    resources[name].loaded = true;
                    updateResourceStatus(name, 'loaded');
                    log(`${name} charg√© avec succ√®s`, 'success');
                    resolve();
                };
                
                script.onerror = (error) => {
                    updateResourceStatus(name, 'error');
                    log(`Erreur lors du chargement de ${name}: ${error}`, 'error');
                    reject(new Error(`Failed to load ${name}`));
                };
                
                document.head.appendChild(script);
            });
        }
        
        // D√©tection de l'environnement
        log('D√©marrage de la simulation', 'info');
        log(`User Agent: ${navigator.userAgent}`, 'info');
        log(`Viewport: ${window.innerWidth}x${window.innerHeight}`, 'info');
        log(`Touch Support: ${('ontouchstart' in window) ? 'Oui' : 'Non'}`, 'info');
        
        // Chargement s√©quentiel des ressources
        async function loadAllResources() {
            try {
                await loadScript('react', resources.react.url);
                await loadScript('reactdom', resources.reactdom.url);
                await loadScript('plotly', resources.plotly.url);
                await loadScript('babel', resources.babel.url);
                
                checkAllResourcesLoaded();
            } catch (error) {
                log(`Erreur critique: ${error.message}`, 'error');
                document.querySelector('.loading-text').textContent = 'Erreur de chargement';
                document.querySelector('.loading-details').textContent = 
                    'V√©rifiez votre connexion internet et rechargez la page';
            }
        }
        
        // V√©rifier si les ressources sont d√©j√† charg√©es (cache)
        function checkPreloadedResources() {
            if (typeof React !== 'undefined') {
                resources.react.loaded = true;
                updateResourceStatus('react', 'loaded');
                log('React d√©j√† en cache', 'success');
            }
            if (typeof ReactDOM !== 'undefined') {
                resources.reactdom.loaded = true;
                updateResourceStatus('reactdom', 'loaded');
                log('ReactDOM d√©j√† en cache', 'success');
            }
            if (typeof Plotly !== 'undefined') {
                resources.plotly.loaded = true;
                updateResourceStatus('plotly', 'loaded');
                log('Plotly d√©j√† en cache', 'success');
            }
            if (typeof Babel !== 'undefined') {
                resources.babel.loaded = true;
                updateResourceStatus('babel', 'loaded');
                log('Babel d√©j√† en cache', 'success');
            }
        }
        
        // Gestion des erreurs globales
        window.onerror = function(msg, url, lineNo, columnNo, error) {
            log(`Erreur JS: ${msg} (ligne ${lineNo})`, 'error');
            return false;
        };
        
        window.onunhandledrejection = function(event) {
            log(`Promise rejet√©e: ${event.reason}`, 'error');
        };
        
        // D√©marrage
        checkPreloadedResources();
        
        // Timeout de s√©curit√©
        const loadingTimeout = setTimeout(() => {
            if (!Object.values(resources).every(r => r.loaded)) {
                log('Timeout de chargement d√©pass√©', 'error');
                document.querySelector('.loading-text').textContent = '‚ö† Timeout de chargement';
                document.querySelector('.loading-details').innerHTML = 
                    'Le chargement prend trop de temps.<br>V√©rifiez votre connexion et <a href="#" onclick="location.reload()" style="color: #00ff00;">rechargez la page</a>';
            }
        }, 30000); // 30 secondes
        
        if (Object.values(resources).every(r => r.loaded)) {
            clearTimeout(loadingTimeout);
            log('Ressources d√©j√† disponibles', 'success');
            checkAllResourcesLoaded();
        } else {
            loadAllResources().then(() => {
                clearTimeout(loadingTimeout);
            });
        }
        
        function initializeApp() {
            log('Initialisation de l\'application React', 'info');
            try {
                // Force le rendu apr√®s un court d√©lai pour s'assurer que Babel est pr√™t
                setTimeout(() => {
                    log('Tentative de rendu React...', 'info');
                }, 100);
            } catch (error) {
                log(`Erreur initialisation: ${error.message}`, 'error');
            }
        }
    </script>

    <script type="text/babel">
        const { useState, useEffect, useRef } = React;

        const CircuitRacingSimulation = () => {
            const canvasRef = useRef(null);
            const [isRunning, setIsRunning] = useState(false);
            const animationRef = useRef(null);
            const plotRef = useRef(null);
            const lastFrameTime = useRef(0);
            const frameCount = useRef(0);
            const lastLogTime = useRef(0);

            useEffect(() => {
                log('Composant React mont√©', 'success');
                log(`Canvas disponible: ${canvasRef.current ? 'Oui' : 'Non'}`, 'info');
                log(`Plotly disponible: ${typeof Plotly !== 'undefined' ? 'Oui' : 'Non'}`, 'info');
            }, []);

            // Configuration du circuit (Circuit de Monaco - Monte Carlo)
            const circuit = {
                checkpoints: [
                    // Ligne de d√©part/arriv√©e - Sainte-D√©vote
                    { x: 100, y: 280, angle: 0 },
                    { x: 150, y: 275, angle: -0.1 },
                    
                    // Virage Sainte-D√©vote (serr√© √† droite)
                    { x: 200, y: 265, angle: -0.4 },
                    { x: 240, y: 245, angle: -0.8 },
                    { x: 270, y: 220, angle: -1.2 },
                    
                    // Mont√©e de Beau Rivage vers Casino
                    { x: 290, y: 190, angle: -1.5 },
                    { x: 310, y: 160, angle: -1.6 },
                    { x: 330, y: 130, angle: -1.7 },
                    { x: 350, y: 105, angle: -1.8 },
                    
                    // Virage du Casino (gauche)
                    { x: 375, y: 85, angle: -2.0 },
                    { x: 405, y: 70, angle: -2.3 },
                    { x: 440, y: 60, angle: -2.6 },
                    
                    // Descente vers Mirabeau
                    { x: 475, y: 55, angle: -2.8 },
                    { x: 510, y: 55, angle: 3.0 },
                    { x: 545, y: 60, angle: 2.9 },
                    
                    // Grand H√¥tel Hairpin (√©pingle tr√®s serr√©e)
                    { x: 575, y: 70, angle: 2.7 },
                    { x: 600, y: 85, angle: 2.4 },
                    { x: 620, y: 105, angle: 2.0 },
                    { x: 630, y: 130, angle: 1.7 },
                    { x: 635, y: 155, angle: 1.5 },
                    
                    // Portier (descente)
                    { x: 635, y: 180, angle: 1.57 },
                    { x: 630, y: 205, angle: 1.6 },
                    
                    // Entr√©e du Tunnel
                    { x: 620, y: 230, angle: 1.7 },
                    { x: 605, y: 250, angle: 1.8 },
                    
                    // Tunnel (ligne droite)
                    { x: 585, y: 270, angle: 2.0 },
                    { x: 560, y: 285, angle: 2.1 },
                    { x: 530, y: 295, angle: 2.2 },
                    { x: 500, y: 300, angle: 2.3 },
                    
                    // Sortie du Tunnel - Chicane du port
                    { x: 470, y: 305, angle: 2.4 },
                    { x: 445, y: 315, angle: 2.6 },
                    { x: 420, y: 320, angle: 2.7 },
                    { x: 395, y: 318, angle: 3.0 },
                    { x: 370, y: 310, angle: 2.8 },
                    
                    // Tabac (virage gauche)
                    { x: 345, y: 300, angle: 2.6 },
                    { x: 320, y: 285, angle: 2.3 },
                    
                    // Piscine (chicane en S)
                    { x: 295, y: 275, angle: 2.1 },
                    { x: 270, y: 270, angle: 1.9 },
                    { x: 245, y: 275, angle: 2.2 },
                    { x: 220, y: 285, angle: 2.4 },
                    
                    // La Rascasse (√©pingle lente)
                    { x: 195, y: 300, angle: 2.6 },
                    { x: 170, y: 310, angle: 2.9 },
                    { x: 145, y: 315, angle: 3.1 },
                    { x: 120, y: 310, angle: 3.3 },
                    
                    // Anthony Nogh√®s (retour vers la ligne)
                    { x: 100, y: 300, angle: 0.2 },
                    { x: 95, y: 290, angle: 0.1 }
                ],
                width: 30 // Plus √©troit que Le Mans (rues de Monaco)
            };

            // √âtat de la simulation
            const simState = useRef({
                playerCar: {
                    position: 0,
                    speed: 0,
                    targetSpeed: 180, // Plus bas que Le Mans (Monaco est un circuit lent)
                    x: 100,
                    y: 280,
                    angle: 0
                },
                otherCars: Array(8).fill(0).map((_, i) => ({
                    position: (i + 1) * 0.11,
                    speed: 120 + Math.random() * 100, // Vitesses Monaco : 120-220 km/h
                    x: undefined,
                    y: undefined,
                    angle: undefined,
                    color: `hsl(${i * 45}, 70%, 50%)`
                })),
                speedHistory: [],
                time: 0,
                lap: 0
            });

            // Fonction pour obtenir la position sur le circuit
            const getCircuitPosition = (progress) => {
                // V√©rifications de s√©curit√©
                if (!circuit || !circuit.checkpoints || circuit.checkpoints.length === 0) {
                    log('getCircuitPosition: circuit non d√©fini', 'error');
                    return null;
                }
                
                if (isNaN(progress) || !isFinite(progress)) {
                    log(`getCircuitPosition: progress invalide (${progress})`, 'error');
                    return null;
                }
                
                const totalCheckpoints = circuit.checkpoints.length;
                const scaledProgress = (progress % 1) * totalCheckpoints;
                const currentIndex = Math.floor(scaledProgress);
                const nextIndex = (currentIndex + 1) % totalCheckpoints;
                const t = scaledProgress - currentIndex;

                const current = circuit.checkpoints[currentIndex];
                const next = circuit.checkpoints[nextIndex];
                
                // V√©rifier que les checkpoints existent
                if (!current || !next) {
                    log(`getCircuitPosition: checkpoint manquant (current: ${currentIndex}, next: ${nextIndex})`, 'error');
                    return null;
                }

                // Interpolation de Catmull-Rom pour un trac√© fluide
                const prevIndex = (currentIndex - 1 + totalCheckpoints) % totalCheckpoints;
                const afterNextIndex = (nextIndex + 1) % totalCheckpoints;
                
                const p0 = circuit.checkpoints[prevIndex];
                const p1 = current;
                const p2 = next;
                const p3 = circuit.checkpoints[afterNextIndex];
                
                // V√©rifier que tous les points existent
                if (!p0 || !p1 || !p2 || !p3) {
                    log(`getCircuitPosition: points d'interpolation manquants`, 'error');
                    return null;
                }

                const t2 = t * t;
                const t3 = t2 * t;

                const x = 0.5 * (
                    (2 * p1.x) +
                    (-p0.x + p2.x) * t +
                    (2 * p0.x - 5 * p1.x + 4 * p2.x - p3.x) * t2 +
                    (-p0.x + 3 * p1.x - 3 * p2.x + p3.x) * t3
                );

                const y = 0.5 * (
                    (2 * p1.y) +
                    (-p0.y + p2.y) * t +
                    (2 * p0.y - 5 * p1.y + 4 * p2.y - p3.y) * t2 +
                    (-p0.y + 3 * p1.y - 3 * p2.y + p3.y) * t3
                );

                // Calcul de l'angle
                const dx = p2.x - p1.x;
                const dy = p2.y - p1.y;
                const angle = Math.atan2(dy, dx);

                return { x, y, angle };
            };

            // D√©tection de proximit√© avec d'autres voitures
            const checkTraffic = (car) => {
                const state = simState.current;
                let minDistance = Infinity;
                
                for (const other of state.otherCars) {
                    const distance = Math.abs(car.position - other.position);
                    const wrappedDistance = Math.min(distance, 1 - distance);
                    if (wrappedDistance < minDistance) {
                        minDistance = wrappedDistance;
                    }
                }

                return minDistance < 0.08; // Trafic d√©tect√© si distance < 8% du circuit (augment√© pour plus d'interactions)
            };
			// Mise √† jour de la physique
            const updatePhysics = (deltaTime) => {
                const state = simState.current;
                if (!state || !state.playerCar) {
                    log('updatePhysics: state non initialis√©', 'error');
                    return;
                }
                
                // V√©rifier que deltaTime est valide
                if (isNaN(deltaTime) || !isFinite(deltaTime) || deltaTime <= 0) {
                    log(`deltaTime invalide: ${deltaTime}`, 'error');
                    return;
                }
                
                // Acc√©l√©ration de la simulation (4x plus rapide)
                const dt = (deltaTime / 1000) * 4.0;
                
                if (isNaN(dt) || !isFinite(dt) || dt <= 0) {
                    log(`dt invalide apr√®s calcul: ${dt}`, 'error');
                    return;
                }

                // Mise √† jour voiture principale
                const player = state.playerCar;
                const pos = getCircuitPosition(player.position);
                
                if (!pos || pos.x === undefined || pos.y === undefined) {
                    log('updatePhysics: position invalide', 'error');
                    return;
                }
                
                // Calcul de la vitesse cible bas√©e sur la courbure
                const nextPos = getCircuitPosition(player.position + 0.01);
                if (!nextPos) {
                    log('nextPos null, impossible de calculer la courbure', 'error');
                    return;
                }
                
                const curvature = Math.abs(nextPos.angle - pos.angle) * 100;
                
                // Variation dans l'approche des virages (pilotage agressif vs conservateur)
                const drivingStyleFactor = 0.85 + Math.random() * 0.3; // 0.85 √† 1.15
                const maxSpeedForCurve = Math.max(80, (260 - curvature * 90) * drivingStyleFactor); // Monaco : virages plus serr√©s
                
                // R√©duction de vitesse si trafic
                const hasTraffic = checkTraffic(player);
                let targetSpeed = hasTraffic ? 
                    Math.min(maxSpeedForCurve * 0.6, player.targetSpeed) : 
                    Math.min(maxSpeedForCurve, player.targetSpeed);
                
                // Variation al√©atoire de la vitesse cible (h√©sitation, confiance)
                targetSpeed += (Math.random() - 0.5) * 15;
                
                // V√©rifier que targetSpeed est valide
                if (isNaN(targetSpeed) || !isFinite(targetSpeed)) {
                    log(`targetSpeed invalide: ${targetSpeed}`, 'error');
                    targetSpeed = 200;
                }

                // Acc√©l√©ration/freinage progressif (plus rapide)
                // This is the first declaration of 'acceleration'
                const currentAccelerationApplied = targetSpeed > player.speed ? 25 : -40; // Renamed this variable
                player.speed += currentAccelerationApplied * dt; // Use the new variable name here
                player.speed = Math.max(60, Math.min(260, player.speed)); // Monaco : 60-260 km/h max
                
                // V√©rifier que la vitesse est valide
                if (isNaN(player.speed) || !isFinite(player.speed)) {
                    log(`Vitesse invalide d√©tect√©e: ${player.speed}, resetting to 150`, 'error');
                    player.speed = 150;
                }

                // Variation al√©atoire plus importante pour simuler le pilotage et conditions variables
                // (vent, temp√©rature piste, usure pneus, etc.)
                const speedVariation = (Math.random() - 0.5) * 20; // ¬±10 km/h
                player.speed += speedVariation;
                
                // Variations suppl√©mentaires bas√©es sur la position (simulation conditions variables)
                const positionFactor = Math.sin(player.position * Math.PI * 8) * 8; // Ondulation
                player.speed += positionFactor;

                // Mise √† jour position
                const speedKmH = player.speed;
                const speedMS = speedKmH / 3.6;
                const circuitLength = 3337; // Circuit de Monaco : 3.337 km
                const deltaPosition = (speedMS * dt) / circuitLength;
                
                // V√©rifier que deltaPosition est valide
                if (isNaN(deltaPosition) || !isFinite(deltaPosition)) {
                    log(`deltaPosition invalide: ${deltaPosition}, speed: ${player.speed}, dt: ${dt}`, 'error');
                    return;
                }
                
                player.position += deltaPosition;
                
                // Normaliser la position pour qu'elle reste dans [0, 1]
                if (player.position >= 1) {
                    player.position = player.position % 1;
                    state.lap++;
                }
                if (player.position < 0) {
                    player.position = 0;
                }

                player.x = pos.x;
                player.y = pos.y;
                player.angle = pos.angle;

                // Enregistrement des statistiques avec acc√©l√©ration
                const previousSpeed = state.speedHistory.length > 0 ? 
                    state.speedHistory[state.speedHistory.length - 1].speed : 
                    speedKmH;
                const dtSeconds = Math.max(0.016, dt); // dt en secondes, min 16ms
                const accelKmhPerSec = (speedKmH - previousSpeed) / dtSeconds;
                // Convertir de km/h/s en m/s¬≤: 1 km/h/s = 1000/3600 m/s¬≤ = 0.2778 m/s¬≤
                // This is the second declaration, causing the error. Renamed it to 'calculatedAcceleration'
                let calculatedAcceleration = state.speedHistory.length > 0 ? // Renamed this variable
                    accelKmhPerSec * 0.2778 :
                    0;
                
                // Limiter les valeurs extr√™mes (F1 peut faire ~5 m/s¬≤ acc√©l√©ration, -5 m/s¬≤ freinage)
                calculatedAcceleration = Math.max(-8, Math.min(8, calculatedAcceleration)); // Use the new variable name here
                
                state.speedHistory.push({
                    speed: Math.round(speedKmH),
                    time: state.time,
                    acceleration: calculatedAcceleration // Use the new variable name here
                });

                // Mise √† jour autres voitures
                state.otherCars.forEach(car => {
                    // Initialiser la position si pas encore fait
                    if (car.x === undefined || car.y === undefined || car.angle === undefined) {
                        const carPos = getCircuitPosition(car.position);
                        if (carPos) {
                            car.x = carPos.x;
                            car.y = carPos.y;
                            car.angle = carPos.angle;
                            log(`Voiture initialis√©e √† (${car.x.toFixed(0)}, ${car.y.toFixed(0)})`, 'info');
                        } else {
                            log(`Impossible d'initialiser la voiture √† position ${car.position}`, 'error');
                            return;
                        }
                    }
                    
                    const carPos = getCircuitPosition(car.position);
                    if (!carPos) {
                        log(`CarPos null pour position ${car.position}`, 'warning');
                        return;
                    }
                    
                    // Variations al√©atoires plus importantes
                    const randomVariation = (Math.random() - 0.5) * 25; // ¬±12.5 km/h
                    car.speed += randomVariation;
                    
                    // Variation bas√©e sur le temps (simulation fatigue pilote, conditions)
                    const timeBasedVariation = Math.sin(state.time * 0.5 + car.position * 10) * 10;
                    car.speed += timeBasedVariation;
                    
                    // Variation bas√©e sur la position sur le circuit
                    const positionVariation = Math.cos(car.position * Math.PI * 12) * 8;
                    car.speed += positionVariation;
                    
                    car.speed = Math.max(80, Math.min(260, car.speed)); // Monaco : 80-260 km/h
                    
                    const carSpeedMS = car.speed / 3.6;
                    const carDeltaPos = (carSpeedMS * dt) / circuitLength;
                    
                    // V√©rifier validit√©
                    if (isNaN(carDeltaPos) || !isFinite(carDeltaPos)) {
                        log(`carDeltaPos invalide: ${carDeltaPos}`, 'error');
                        return;
                    }
                    
                    car.position = (car.position + carDeltaPos) % 1;
                    if (car.position < 0) car.position += 1;
                    
                    car.x = carPos.x;
                    car.y = carPos.y;
                    car.angle = carPos.angle;
                });

                state.time += dt;
            };
           
            // Calcul des statistiques par palier de vitesse
			// Analyse bivari√©e : vitesse √ó dur√©e cons√©cutive
const calculateStats = () => {
    const history = simState.current.speedHistory;
    if (history.length < 2) return null;

    const speedBins = [];
    for (let s = 80; s <= 360; s += 10) speedBins.push(s);

    const durationBinSize = 0.1; // secondes
    const maxDuration = 8;       // borne raisonnable
    const durationBins = [];
    for (let d = 0; d <= maxDuration; d += durationBinSize) {
        durationBins.push(parseFloat(d.toFixed(1)));
    }

    // Extraction des s√©quences
    let sequences = [];
    let currentSpeed = null;
    let currentDuration = 0;

    for (let i = 0; i < history.length - 1; i++) {
        const s1 = Math.floor(history[i].speed / 10) * 10;
        const s2 = Math.floor(history[i+1].speed / 10) * 10;
        const dt = history[i+1].time - history[i].time;

        if (s1 === currentSpeed) {
            currentDuration += dt;
        } else {
            if (currentSpeed !== null) {
                sequences.push({
                    speed: currentSpeed,
                    duration: currentDuration
                });
            }
            currentSpeed = s1;
            currentDuration = dt;
        }
    }

    // Pousser la derni√®re s√©quence
    sequences.push({
        speed: currentSpeed,
        duration: currentDuration
    });

    // Matrice 2D : vitesse √ó dur√©e ‚Üí fr√©quence
    const matrix = {};
    speedBins.forEach(s => {
        matrix[s] = {};
        durationBins.forEach(d => matrix[s][d] = 0);
    });

    // Remplit la matrice
    sequences.forEach(seq => {
        const durBin = Math.floor(seq.duration / durationBinSize) * durationBinSize;
        const durBinRounded = parseFloat(durBin.toFixed(1));
        if (matrix[seq.speed]?.[durBinRounded] !== undefined) {
            matrix[seq.speed][durBinRounded]++;
        }
    });

    const total = sequences.length;

    // Conversion en pourcentage
    const Z = speedBins.map(s =>
        durationBins.map(d => (matrix[s][d] / total) * 100)
    );

    return { speedBins, durationBins, Z };
};

         const updatePlot = () => {
    const stats = calculateStats();
    if (!stats) return;

    const { speedBins, durationBins, Z } = stats;

    const trace = {
        type: "surface",
        x: speedBins,
        y: durationBins,
        z: Z,
        colorscale: "Viridis",
        showscale: true,
        contours: {
            z: { show: true, usecolormap: true, highlightcolor: "#fff" }
        }
    };

    const layout = {
        title: {
            text: "Bivariate Distribution duration x speed",
            font: { color: "#ffffff", size: 16 }
        },
        scene: {
            xaxis: {
                title: "Speed (km/h)",
                titlefont: { color: "#ffffff" },
                tickfont: { color: "#ffffff" }
            },
            yaxis: {
                title: "Duration (s)",
                titlefont: { color: "#ffffff" },
                tickfont: { color: "#ffffff" }
            },
            zaxis: {
                title: "Percentage (%)",
                titlefont: { color: "#ffffff" },
                tickfont: { color: "#ffffff" }
            },
            bgcolor: "#1a1a1a"
        },
        paper_bgcolor: "#1a1a1a",
        plot_bgcolor: "#1a1a1a",
        margin: { l: 0, r: 0, t: 40, b: 0 }
    };

    const config = {
        responsive: true,
        displayModeBar: true,
        modeBarButtonsToRemove: ["toImage"],
        displaylogo: false
    };

    Plotly.react(plotRef.current, [trace], layout, config);
};

            
            // Rendu du circuit et des voitures
            const render = () => {
                const canvas = canvasRef.current;
                if (!canvas) {
                    log('Render: canvas non disponible', 'warning');
                    return;
                }

                const ctx = canvas.getContext('2d');
                if (!ctx) {
                    log('Render: contexte 2D non disponible', 'error');
                    return;
                }
                
                const state = simState.current;
                if (!state || !state.playerCar) {
                    log('Render: state non initialis√©', 'error');
                    return;
                }

                try {
                    // Clear
                    ctx.fillStyle = '#0a0a0a';
                    ctx.fillRect(0, 0, canvas.width, canvas.height);

                // Dessiner le circuit
                ctx.strokeStyle = '#333';
                ctx.lineWidth = circuit.width;
                ctx.lineCap = 'round';
                ctx.lineJoin = 'round';
                
                ctx.beginPath();
                for (let i = 0; i <= 100; i++) {
                    const pos = getCircuitPosition(i / 100);
                    if (i === 0) {
                        ctx.moveTo(pos.x, pos.y);
                    } else {
                        ctx.lineTo(pos.x, pos.y);
                    }
                }
                ctx.closePath();
                ctx.stroke();

                // Bordures du circuit
                ctx.strokeStyle = '#ff0000';
                ctx.lineWidth = 2;
                ctx.stroke();

                // Ligne de d√©part/arriv√©e
                const startPos = circuit.checkpoints[0];
                ctx.strokeStyle = '#ffffff';
                ctx.lineWidth = 3;
                ctx.beginPath();
                ctx.moveTo(startPos.x - 15, startPos.y - 20);
                ctx.lineTo(startPos.x - 15, startPos.y + 20);
                ctx.stroke();

                // Dessiner les autres voitures
                state.otherCars.forEach(car => {
                    if (car && car.x !== undefined && car.y !== undefined && car.angle !== undefined) {
                        ctx.save();
                        ctx.translate(car.x, car.y);
                        ctx.rotate(car.angle);
                        
                        ctx.fillStyle = car.color;
                        ctx.fillRect(-8, -4, 16, 8);
                        ctx.fillStyle = '#000';
                        ctx.fillRect(-8, -4, 6, 8);
                        
                        ctx.restore();
                    }
                });

                // Dessiner la voiture principale
                const player = state.playerCar;
                if (player && player.x !== undefined && player.y !== undefined && player.angle !== undefined) {
                    ctx.save();
                    ctx.translate(player.x, player.y);
                    ctx.rotate(player.angle);
                
                    ctx.fillStyle = '#00ff00';
                    ctx.fillRect(-10, -5, 20, 10);
                    
                    ctx.fillStyle = '#ffffff';
                    ctx.fillRect(-2, -4, 6, 8);
                    
                    ctx.fillStyle = '#ff0000';
                    ctx.fillRect(-10, -6, 3, 12);
                    
                    ctx.restore();

                    // Affichage des infos
                    ctx.fillStyle = '#ffffff';
                    ctx.font = 'bold 18px monospace';
                    ctx.fillText(`Speed: ${Math.round(player.speed)} km/h`, 10, 30);
                    ctx.fillText(`Turn: ${state.lap}`, 10, 55);
                    ctx.fillText(`Time: ${state.time.toFixed(1)}s`, 10, 80);
                    
                    if (checkTraffic(player)) {
                        ctx.fillStyle = '#ff9900';
                        ctx.fillText('‚ö† TRAFIC', 10, 105);
                    }
                    
                    // Indicateur d'animation (point clignotant)
                    if (isRunning) {
                        const pulseAlpha = (Math.sin(state.time * 5) + 1) / 2;
                        ctx.fillStyle = `rgba(0, 255, 0, ${pulseAlpha})`;
                        ctx.beginPath();
                        ctx.arc(canvas.width - 20, 20, 8, 0, Math.PI * 2);
                        ctx.fill();
                        
                        // Text "LIVE"
                        ctx.fillStyle = '#00ff00';
                        ctx.font = 'bold 12px monospace';
                        ctx.fillText('LIVE', canvas.width - 55, 25);
                    }
                } else {
                    log('Player position non d√©finie', 'warning');
                }
                } catch (error) {
                    log(`Erreur render: ${error.message}`, 'error');
                    console.error('Render error:', error);
                }
            };

            // Boucle d'animation
            const animate = (timestamp) => {
                try {
                    const deltaTime = timestamp - (animationRef.current || timestamp);
                    animationRef.current = timestamp;
                    
                    frameCount.current++;
                    
                    // Log p√©riodique des performances (toutes les 3 secondes)
                    if (timestamp - lastLogTime.current > 3000) {
                        const elapsed = (timestamp - lastLogTime.current) / 1000;
                        const fps = (frameCount.current / elapsed).toFixed(1);
                        log(`Performance: ${fps} FPS, ${frameCount.current} frames en ${elapsed.toFixed(1)}s`, 'info');
                        frameCount.current = 0;
                        lastLogTime.current = timestamp;
                    }

                    updatePhysics(Math.min(deltaTime, 50));
                    render();

                    if (isRunning) {
                        requestAnimationFrame(animate);
                    }
                } catch (error) {
                    log(`Erreur animation: ${error.message}`, 'error');
                    console.error(error);
                    setIsRunning(false); // Arr√™ter l'animation en cas d'erreur
                }
            };

            // Effets
            useEffect(() => {
                if (isRunning) {
                    log('Animation d√©marr√©e', 'success');
                    animationRef.current = performance.now();
                    lastLogTime.current = performance.now();
                    frameCount.current = 0;
                    requestAnimationFrame(animate);
                    
                    const interval = setInterval(() => {
                        try {
                            updatePlot();
                        } catch (error) {
                            log(`Erreur mise √† jour plot: ${error.message}`, 'error');
                        }
                    }, 500);

                    return () => {
                        log('Animation arr√™t√©e', 'info');
                        clearInterval(interval);
                    };
                }
            }, [isRunning]);

            useEffect(() => {
                if (plotRef.current) {
                    try {
                        log('Initialisation du graphique 3D', 'info');
                        updatePlot();
                    } catch (error) {
                        log(`Erreur init plot: ${error.message}`, 'error');
                    }
                }
            }, []);

            const toggleSimulation = () => {
                log(`Toggle simulation: ${isRunning ? 'STOP' : 'START'}`, 'info');
                
                try {
                    if (!canvasRef.current) {
                        log('Canvas non disponible!', 'error');
                        return;
                    }
                    
                    if (!isRunning) {
                        log('V√©rification avant d√©marrage...', 'info');
                        
                        // Test du canvas
                        const ctx = canvasRef.current.getContext('2d');
                        if (!ctx) {
                            log('Impossible d\'obtenir le contexte 2D', 'error');
                            return;
                        }
                        log('Contexte 2D OK', 'success');
                        
                        // Reset si n√©cessaire
                        if (simState.current.lap > 0) {
                            log('Reset de la simulation', 'info');
                            simState.current = {
                                playerCar: {
                                    position: 0,
                                    speed: 0,
                                    targetSpeed: 180,
                                    x: 100,
                                    y: 280,
                                    angle: 0
                                },
                                otherCars: Array(8).fill(0).map((_, i) => ({
                                    position: (i + 1) * 0.11,
                                    speed: 120 + Math.random() * 100,
                                    x: undefined,
                                    y: undefined,
                                    angle: undefined,
                                    color: `hsl(${i * 45}, 70%, 50%)`
                                })),
                                speedHistory: [],
                                time: 0,
                                lap: 0
                            };
                        }
                        
                        log('Configuration simulation OK', 'success');
                    }
                    
                    setIsRunning(!isRunning);
                } catch (error) {
                    log(`Erreur toggle: ${error.message}`, 'error');
                    console.error(error);
                }
            };

            return (
                <div className="container">
                    <h1>üèéÔ∏è Monaco Circuit Simulation </h1>
                    <p className="subtitle">
                          2D real time animation + 3D Analysis
                    </p>
                    
                    <div style={{ 
                        textAlign: 'center', 
                        padding: '10px', 
                        background: 'rgba(0, 255, 0, 0.1)', 
                        borderRadius: '5px', 
                        marginBottom: '15px',
                        border: '1px solid rgba(0, 255, 0, 0.3)'
                    }}>
                        <span style={{ color: '#00ff00', fontWeight: 'bold' }}>‚úì Application loaded</span>
                        {' ‚Ä¢ '}
                        <span style={{ color: '#888' }}>Click Start to launch simulation</span>
                    </div>

                    <div className="main-grid">
                        <div className="circuit-panel">
                            <canvas
                                ref={canvasRef}
                                width={800}
                                height={400}
                            />
                            
                            <div className="controls">
                                <button
                                    onClick={toggleSimulation}
                                    className={isRunning ? 'stop' : 'start'}
                                >
                                    {isRunning ? '‚è∏ Pause' : '‚ñ∂ Start'}
                                </button>
                            </div>

                            <div className="legend">
                                <h3>üèÅ Legend</h3>
                                <div className="legend-items">
                                    <div className="legend-item">
                                        <div className="legend-color" style={{ backgroundColor: '#00ff00' }}></div>
                                        <span>Your car</span>
                                    </div>
                                    <div className="legend-item">
                                        <div className="legend-color" style={{ backgroundColor: '#ff9900' }}></div>
                                        <span>8 competing cars</span>
                                    </div>
                                    <div className="legend-item">
                                        <div className="legend-color" style={{ backgroundColor: '#fff', height: '2px' }}></div>
                                        <span>Finish/Start Line</span>
                                    </div>
                                </div>
                            </div>
                        </div>

                        <div className="plot-panel">
                            <div id="plot3d" ref={plotRef}></div>
                            
                            <div className="info-box">
                                <h3>üìä 3D Interactive Analysis</h3>
                                <p><strong>X Axis</strong> : Speed km/h (10 km/h steps)</p>
                                <p><strong>Y Axis</strong> : Duration</p>
                                <p><strong>Z Axis</strong> : Frequency)</p>
                                <p style={{ marginTop: '15px', color: '#00ff00' }}>
                                    üñ±Ô∏è <strong>Rotation 3D</strong> : Click and drag to pivot graph
                                </p>
                                <p className="stats-note">
                                    üí° 3D graphique 3D show complex relationship between speed, duration and probability :
                                    <br/>‚Ä¢ <strong>Acc√©l√©rations positives</strong> : zones de sortie de virage et ligne droite
                                    <br/>‚Ä¢ <strong>Acc√©l√©rations n√©gatives</strong> : zones de freinage avant virages
                                    <br/>‚Ä¢ <strong>Acc√©l√©rations proches de 0</strong> : vitesse stable dans les virages rapides
                                    <br/>‚Ä¢ Points dispers√©s en 3D gr√¢ce aux m√©triques ind√©pendantes
                                    <br/><br/>Monaco specifics :
                                    ‚Ä¢ Grand H√¥tel Hairpin : forte d√©c√©l√©ration puis acc√©l√©ration
                                    ‚Ä¢ Tunnel : vitesse max, acc√©l√©ration faible
                                    ‚Ä¢ Piscine : acc√©l√©rations variables (chicane)
                                    ‚Ä¢ Rascasse : forte d√©c√©l√©ration
                                    <br/>Le graphique se met √† jour en temps r√©el avec maintien de votre angle de vue.
                                </p>
                            </div>
                        </div>
                    </div>
                </div>
            );
        };

        // Rendu de l'application
        try {
            log('Tentative de cr√©ation du root React', 'info');
            const rootElement = document.getElementById('root');
            
            if (!rootElement) {
                log('Element root introuvable!', 'error');
                throw new Error('Root element not found');
            }
            
            log('Element root trouv√©', 'success');
            
            if (typeof React === 'undefined' || typeof ReactDOM === 'undefined') {
                log('React ou ReactDOM non disponible!', 'error');
                throw new Error('React not loaded');
            }
            
            log('React et ReactDOM disponibles', 'success');
            
            const root = ReactDOM.createRoot(rootElement);
            log('Root React cr√©√© avec succ√®s', 'success');
            
            root.render(<CircuitRacingSimulation />);
            log('Composant rendu avec succ√®s', 'success');
            
        } catch (error) {
            log(`Erreur fatale lors du rendu: ${error.message}`, 'error');
            console.error('Fatal render error:', error);
            
            // Afficher un message d'erreur √† l'utilisateur
            const rootElement = document.getElementById('root');
            if (rootElement) {
                rootElement.innerHTML = `
                    <div style="padding: 40px; text-align: center; color: white;">
                        <h2 style="color: #ff4444;">‚ùå Erreur de chargement</h2>
                        <p style="margin: 20px 0; color: #ccc;">Une erreur s'est produite lors du chargement de l'application.</p>
                        <p style="color: #888; font-size: 14px;">Erreur: ${error.message}</p>
                        <button onclick="location.reload()" style="
                            margin-top: 20px;
                            padding: 12px 30px;
                            background: #00ff00;
                            color: #000;
                            border: none;
                            border-radius: 25px;
                            cursor: pointer;
                            font-weight: bold;
                        ">üîÑ Recharger la page</button>
                        <p style="margin-top: 20px; color: #888; font-size: 12px;">
                            Cliquez sur le bouton Debug en bas √† droite pour plus d'informations
                        </p>
                    </div>
                `;
            }
        }
    </script>
</body>
</html>